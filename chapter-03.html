<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Dave Kinkead">
  <title>Argumentum in Silico</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="assets/styles.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Argumentum in Silico</h1>
<p class="author">Dave Kinkead</p>
</header>
<h2 id="introduction">Introduction</h2>
<ul>
<li>Simulation has much to offer philosophy</li>
<li>But simulation also faces methodological challenges</li>
<li>Simulation as argument overcomes these challenges</li>
<li>Simulation as argument also offers additional benefits</li>
<li>Philosophy should embrace simulation as argument</li>
</ul>
<h2 id="accessability">Accessability</h2>
<p>Many problems of interest to philosophers exist in domains that are difficult to access empricially.</p>
<h2 id="complexity">Complexity</h2>
<p>Complex system have emergent behaviour</p>
<h2 id="intractability">Intractability</h2>
<p>Some problems cannot be solved analytically</p>
<p>&quot;Computer simulations extend the class of tractable mathematics and thereby broaden the range of modelling tools that we can use.&quot; <span class="citation" data-cites="frigg2009">Frigg and Reiss (2009)</span> p594</p>
<p>issues - approximation - trunctation - interpretation</p>
<h2 id="reproducability">Reproducability</h2>
<p>Simulation however, also comes with its own limitations.</p>
<ul>
<li>reality</li>
<li>replication</li>
<li>reliability</li>
</ul>
<h2 id="simulation-as-argument">Simulation as Argument</h2>
<p>Simulation has been used in a number of ways in science and philosophy - to predict and test theory - to generate data</p>
<p>We might call this approach <em>argumentum cum silico</em>.</p>
<p>Literate programming offers us another avenue of use.</p>
<p>Call this <em>argumentum in silico</em>.</p>
<p>What can this do for philosophy?</p>
<ul>
<li>model theory rather than reality</li>
<li>act as a coherence test for our theories when empiric data is unavailable</li>
<li>is a theory's conclusion entailed by its assumptions and premises</li>
<li>show what's possible or even plausible plausible</li>
</ul>
<h2 id="demonstatration">Demonstatration</h2>
<h2 id="persuasion">Persuasion</h2>
<p>Graphic</p>
<blockquote>
<p>On pages 112-114 Humphreys seems to suggest thatthe fact that theoutputsof simulationsarerepresentedvisuallybearsspecialweight.</p>
</blockquote>
<p>Dynamic</p>
<p>Believable - Counter intuitive results are more likely to be accepted</p>
<p>Clarity - Simulation forces us to be explicit when we might otherwise hand wave.</p>
<h3 id="models-of-segregation">Models of Segregation</h3>
<p>Rather than labour the point futher, I think a demonstration of <em>simulation as argument</em> would be germane. In what follows, I'll reproduce Thomas Schelling's seminal work <em>Models of Segregation</em> in order to highlight the advantages of this method for philosophy.</p>
<p>---&gt; Racial segregation was a pertinent topic in 1969 and remains one today.....</p>
<p>Some types of segregation might be justified as &quot;socially efficient satisfaction of individual preferences&quot; (p488) but Schelling doubted racial segregation was one such type because urban demographics in the US were so extremely U-shaped -- neighbourhoods were nearly all white or nearly all black with very few mixed below 75% of a single race.</p>
<p>This is a problem with an abundance of empiric data at the system level but a complete absence at the individual level. Detail demographic data existed showing the exact racial make up of urban neighbourhoods but there was little data on individual preferences concerning their neighbourhood demographics -- did whites and blacks prefer exclusively white and black neighbourhoods or were they satisfied to live in mixed ones? Even if individual racial preference data was obtainable through a mechanism like surveys, there are strong grounds to doubt its accuracy owing the socially delicate nature of the question -- few like to admit to being being racist.</p>
<p>By formalising the problem however, some constraints become apparent -- if both blacks and whites want to be in the majority within their neighbourhood, then these preferences are not mutually compatible within integrated communities. The minimum threshold for 'racial likeness' for different races must sum to less that 100%. If it exceeds 100%, then either individuals will be forced to move or the racial composition of the neighbourhood will not be a &quot;socially efficient satisfaction&quot;.</p>
<p>In his original 1969 work, Schelling used naughts and crosses in a one-dimensional plane to show how a random distribution of races (or any categorically distinct difference) will not be socially efficient if individuals have a greater than 50% preferences for living amongst those similar to themselves. Schelling's key insight was that</p>
<blockquote>
<p>the interplay of individual choices, where unorganised segregation is concerned, is a complex system with collective results that bear no close relation to individual intent. (p488)</p>
</blockquote>
<p>This conclusion is profound yet counter-inuitive -- even if everyone is perfectly content with living in a mixed-race neighbourhood, complete racial stratification remains the stable equilibrium whenever individuals have a preference being more than the slightest majority.</p>
<p>Yet as important as Schelling's insight into complex and emergent systems was, his method of manually shifting naughts and crosses on paper had obvious limitations. How does the conception of neighbourhood depth relate to the likelihood of stratification? What happens when more than two races are present? As Schelling himself acknowledges:</p>
<blockquote>
<p>All of this is too abstract to be a motion picture of whites and blacks or boys and girls choosing houses on a road or even stools along a counter; but it is suggestive of some of the dynamics that could be present in individually motivated segregation. (p491)</p>
</blockquote>
<p>---&gt; His response was to model the problem at a system level. By making some simplifying assumptions, Schelling constructed intersecting parabolas representing frequency distributions of whites and blacks shaped according to their stipulated racial-mix preference. .....</p>
<p>---&gt; the problem of system level analysis....</p>
<p>Computer simulation can answer these questions. Simulation as argument makes the results more pursuasive.</p>
<p>Rather than model a system as Schelling did, we are going to model agents acting independently and observe any emergent system level behaviours. Like Schelling's naughts and crosses model, our's will consist soley of agents who have:</p>
<ul>
<li>a conception of neighbourhood based on geographic proximity</li>
<li>a degree of satisfaction based tolerance ratios being satisfied</li>
<li>an ability to move if unhappy</li>
</ul>
<p>The first step is to formalise our agents. To instantiate an agent, we will give it a set of parameters specifying its race, how deep it perceives it neighbourhood to be, and minimum tolerance for racial similarity within their neighbourhood. We'll also randomly assign them to somewhere in a two-dimensional space.</p>
<pre><code>class Agent
  constructor: (@race, @tolerance, @depth) -&gt;
    @x = Math.floor Math.random() * space.width
    @y = Math.floor Math.random() * space.height        </code></pre>
<p>Agents are happy if the composition of their neighbourhood is within their tolerance. A low tolerance for diversity should should correlate with greater levels of unhappiness, all other things being equal.</p>
<pre><code>  isHappy: () -&gt;</code></pre>
<div id="space">

</div>
<h2 id="the-model">The Model</h2>
<p>Rather than model a system as Schelling did, we are going to model agents acting independently and observe any emergent system level behaviours. This means we are going to need agents with:</p>
<ul>
<li>satisfaction based on how far one's neighbourhood extends</li>
<li>happiness depends on tolerance ratios being satisfied</li>
<li>agents move if unhappy</li>
</ul>
<p>We start with our agents. Our agents exist in a 2D space, are of a certain race, and hold a xenophobic disposition. For now, we will randomly assign them their race and geographic location. Their xenophobia will also be a function of their race.</p>
<p>In this case, we will create 3 races of agents and give them a xenophobia level of just 40% (ie agent will only be happy if more than 40% of thier neighbours are the same).</p>
<pre><code>class Agent
  constructor: (@space) -&gt;
    [@race, @xenophobia] = switch Math.floor Math.random() * 3
              when 0 then [&quot;blue&quot;, 0.4]
              when 1 then [&quot;red&quot;, 0.4]
              when 2 then [&quot;green&quot;, 0.4]
    @x = Math.floor Math.random() * @space.width
    @y = Math.floor Math.random() * @space.height
    @step   = 50 
    @depth = 100</code></pre>
<p>The happiness of agents is determined by their neighbourhood composition. If the homogeniality is greater than their xenophobia, then they are happy. High levels of xenophobia should correlate with greater levels of unhappiness, all other things being equal.</p>
<pre><code>  isHappy: () -&gt;
    homogeneity = @space.homogeneity(this)
    if homogeneity &gt;= @xenophobia then true else false</code></pre>
<p>Next, we difine a 2D space representing the problem domain. Our space contains a geographical distribution of agents stored in a list. We also give a space a width and height to manage the relation between the simulation and the client.</p>
<pre><code>class Space
  constructor: (@height, @width) -&gt;
    @agents = []</code></pre>
<p>In spacial arranements, everybody is next to somebody - their neighbour. The relative composition of that neighbourhood - 10% homogeniality or 50% homogeniality - is determined by the race of ones neighbours and how deep the conception of neighbourhood extends.</p>
<pre><code>Space::neighbourhood = (x, y) -&gt;
  neighbours = []
  for other in @agents
    if x - other.depth &lt; other.x &lt; x + other.depth and y - other.depth &lt; other.y &lt; y + other.depth
      neighbours.push other
  neighbours</code></pre>
<p>The homogeniality of a neighbourhood relative to an agent is therefore calculated as the proportion of like neighbours to total neighbours.</p>
<pre><code>Space::homogeneity = (agent) -&gt;
  same = 0
  others = 0
  neighbours = this.neighbourhood agent.x, agent.y
  for neighbour in neighbours
    same += 1 if agent.race is neighbour.race
    others += 1 if agent.race isnt neighbour.race
  same / (same + others)</code></pre>
<p>Now that we have defined our model, we need some functions to initiate and control behaviour. We will instantiate the simulation by invoking the <code>agents</code> function. This will create a space and populate it with agents.</p>
<pre><code>agents = (height, width) -&gt;
  space = new Space(height, width)
  for n in [1..2000]
    space.agents.push new Agent space 
  space.agents</code></pre>
<p>We then need some logic for moving our agents around the space. Movement could be intentionally directed or (as in this case), agents move to a random spot near by, only moving if they are unhappy with their neighbourhood.</p>
<pre><code>move = (agent) -&gt;
  unless agent.isHappy()
    xRand = Math.random() * agent.step
    yRand = Math.random() * agent.step
    agent.x += xRand - agent.step / 2
    agent.x = xRand / 2 if agent.x &lt; 0
    agent.x = agent.space.width - xRand /2 if agent.x &gt; agent.space.width
    agent.y += yRand - agent.step / 2
    agent.y = yRand /2 if agent.y &lt; 0
    agent.y = agent.space.height - yRand / 2 if agent.y &gt; agent.space.height</code></pre>
<p>Finally, we declare our public API so that other modules can access it.</p>
<pre><code>simulation = {agents: agents, move: move}</code></pre>
<h2 id="browser-code">Browser Code</h2>
<p>This is the browser file where we pull together different parts of the simulation and wrap it up in the browser. We'll start out by importing our libraries and defining any global variables we might need.</p>
<pre><code>d3      = require &#39;d3&#39;
running = false
height  = window.innerHeight  - 40 || 600
width   = window.innerWidth - 40 || 600</code></pre>
<p>Next, we'll grab create our svg canvas, apply some event listeners and add it to the DOM.</p>
<pre><code>canvas = d3.select(&quot;#space&quot;)
            .append(&quot;svg:svg&quot;)
            .attr(&quot;height&quot;, height)
            .attr(&quot;width&quot;, width)
            .on &quot;click&quot;, () -&gt;
              running = if running is true then false else true
            </code></pre>
<p>Now we need to createsvg circles to represent our agents and bind them to the actual agents from the simulation. The <code>d</code> in the functions here is the D3js accessor to the agent data.</p>
<pre><code>populate = () -&gt;
  canvas.selectAll &quot;circle&quot;
    .data simulation.agents(height, width)
    .enter().append &quot;circle&quot;
    .style &quot;fill&quot;, (d) -&gt; d.race 
    .style &quot;opacity&quot;, 0.5
    .attr &quot;r&quot;, 8
    .attr &quot;cx&quot;, (d) -&gt; d.x
    .attr &quot;cy&quot;, (d) -&gt; d.y

populate()</code></pre>
<p>We then write a loop where each svg circle triggers the move function for its bound agent.</p>
<pre><code>move = () -&gt;
  circles = canvas.selectAll &quot;circle&quot;
  circles.each (d) -&gt;
    d = simulation.move d
  .transition()
  .duration 50
  .attr &quot;cx&quot;, (d) -&gt; d.x
  .attr &quot;cy&quot;, (d) -&gt; d.y

run = () -&gt;
  move() unless running is false</code></pre>
<p>Finally, we run the loop continuous with a half second pause.</p>
<pre><code>setInterval run, 50</code></pre>
<div class="references">
<p>Frigg, Roman, and Julian Reiss. 2009. “The Philosophy of Simulation: Hot New Issues or Same Old Stew?” <em>Synthese</em> 169 (3). Springer: 593–613.</p>
</div>
</body>
</html>